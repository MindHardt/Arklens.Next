using System;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using System.Threading;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace Arklens.Next.Generators;

[Generator]
public class EnumerationGenerator : IIncrementalGenerator
{
    public const string Namespace = nameof(EnumerationGenerator);

    public const string GeneratedCodeAttributeText =
        $"[global::System.CodeDom.Compiler.GeneratedCode(\"{nameof(EnumerationGenerator)}\", \"1.1\")]";

    public const string AttributeFullName = AttributeShortName + nameof(Attribute);
    public const string AttributeShortName = "GenerateEnumeration";
    public const string AttributeSourceText =
        $$"""
          // <auto-generated>
          
          namespace {{Namespace}}
          {
            /// <summary>
            /// Indicates that decorated class should source-generate an <see cref="{{InterfaceName}}{T}"/>
            /// implementation using its public static get properties of its own type.
            /// </summary>
            
            {{GeneratedCodeAttributeText}}
            [global::System.AttributeUsage(global::System.AttributeTargets.Class | global::System.AttributeTargets.Struct)]
            public class {{AttributeFullName}} : global::System.Attribute
            { 
            }
          }
          """;

    public const string InterfaceName = "IEnumeration";
    public const string InterfaceProperty = "AllValues";

    public const string InterfaceSourceText =
        $$"""
          // <auto-generated>
          using global::System.Collections.Generic;
          
          namespace {{Namespace}}
          {
            /// <summary>
            /// Exposes a property with all possible values of <typeparamref name="T"/>.
            /// </summary>
            /// <typeparam name="T">
            /// The enumerated type. 
            /// It is expected but not required 
            /// to be the implementing type.
            /// </typeparam>
            {{GeneratedCodeAttributeText}}
            public interface {{InterfaceName}}<T>
            {
                /// <summary>
                /// Contains all the values of <typeparamref name="T"/>.
                /// </summary>
                public abstract static global::System.Collections.Generic.IReadOnlyCollection<T> {{InterfaceProperty}} { get; }
            }
          }
          """;

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        context.RegisterPostInitializationOutput(ctx =>
        {
            ctx.AddSource(
                $"{AttributeFullName}.g.cs",
                SourceText.From(AttributeSourceText, Encoding.UTF8));
            ctx.AddSource(
                $"{InterfaceName}.g.cs",
                SourceText.From(InterfaceSourceText, Encoding.UTF8));
        });

        var provider = context.SyntaxProvider.CreateSyntaxProvider(
            (node, _) => node is TypeDeclarationSyntax, Transform)
            .Where(x => x.shouldGenerate)
            .Select((x, _) => x.type);

        context.RegisterSourceOutput(context.CompilationProvider.Combine(provider.Collect()),
            (ctx, t) => GenerateCode(ctx, t.Left, t.Right));
    }

    private static (TypeDeclarationSyntax type, bool shouldGenerate) Transform(
        GeneratorSyntaxContext ctx,
        CancellationToken ct)
    {
        var type = (TypeDeclarationSyntax)ctx.Node;

        // Go through all attributes of the class.
        foreach (var attributeList in type.AttributeLists)
        foreach (var attribute in attributeList.Attributes)
        {
            ct.ThrowIfCancellationRequested();

            if (ctx.SemanticModel.GetSymbolInfo(attribute).Symbol is not IMethodSymbol attributeSymbol)
                continue;

            var attributeName = attributeSymbol.ContainingType.ToDisplayString();

            // Check the full name of the [Report] attribute.
            if (attributeName == $"{Namespace}.{AttributeFullName}")
                return (type, true);
        }

        return (type, false);
    }

    private static void GenerateCode(
        SourceProductionContext context,
        Compilation compilation,
        ImmutableArray<TypeDeclarationSyntax> typeDeclarations)
    {
        foreach (var type in typeDeclarations)
        {
            var semanticModel = compilation.GetSemanticModel(type.SyntaxTree);

            if (semanticModel.GetDeclaredSymbol(type) is not INamedTypeSymbol classSymbol)
                continue;

            var namespaceName = classSymbol.ContainingNamespace.ToDisplayString();

            var typeName = type.Identifier.Text;
            var keyword = type switch
            {
                ClassDeclarationSyntax cds => cds.Keyword.Text,
                StructDeclarationSyntax sds => sds.Keyword.Text,
                RecordDeclarationSyntax rds => $"{rds.Keyword.Text} {rds.ClassOrStructKeyword.Text}".TrimEnd(),
                _ => "class"
            };

            var properties = classSymbol.GetMembers()
                .OfType<IPropertySymbol>()
                .Where(x => x is
                {
                    IsStatic: true,
                    IsReadOnly: true
                });

            var code =
                $$"""
                  // <auto-generated/>

                  using global::System.Collections.Generic;
                  using global::{{Namespace}};

                  namespace {{namespaceName}};

                  {{GeneratedCodeAttributeText}}
                  partial {{keyword}} {{typeName}} : global::{{Namespace}}.{{InterfaceName}}<{{typeName}}>
                  {
                      public static new global::System.Collections.Generic.IReadOnlyCollection<{{typeName}}> {{InterfaceProperty}} { get; } = 
                      [
                  {{string.Join(",\n", properties.Select(x => $"\t\t{x.Name}"))}}
                      ];
                  }

                  """;

            context.AddSource($"{typeName}.g.cs", SourceText.From(code, Encoding.UTF8));
        }
    }
}