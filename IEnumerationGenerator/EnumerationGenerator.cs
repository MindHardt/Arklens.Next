using System.Collections.Immutable;
using System.Linq;
using System.Text;
using System.Threading;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace IEnumerationGenerator;

[Generator]
public class EnumerationGenerator : IIncrementalGenerator
{
    public const string ToolName = nameof(EnumerationGenerator);
    public const string Namespace = nameof(EnumerationGenerator);
    public const string AttributeName = "GenerateEnumeration";
    public const string AttributeSourceText =
        $$"""
          // <auto-generated>
          
          namespace {{Namespace}}
          {
          
            [global::System.CodeDom.Compiler.GeneratedCode("{{ToolName}}", "1.0")]
            [global::System.AttributeUsage(global::System.AttributeTargets.Class | global::System.AttributeTargets.Struct)]
            public class {{AttributeName}} : global::System.Attribute
            { 
            }
          }
          """;

    public const string InterfaceName = "IEnumeration";
    public const string InterfaceProperty = "AllValues";

    public const string InterfaceSourceText =
        $$"""
          // <auto-generated>
          using global::System.Collections.Generic;
          
          namespace {{Namespace}}
          {
            /// <summary>
            /// Exposes a property with all possible values of <typeparamref name="T"/>.
            /// </summary>
            /// <typeparam name="T">
            /// The enumerated type. 
            /// It is expected but not required 
            /// to be the implementing type.
            /// </typeparam>
            [global::System.CodeDom.Compiler.GeneratedCode("{{ToolName}}", "1.0")]
            public interface {{InterfaceName}}<T>
            {
                /// <summary>
                /// Contains all the values of <typeparamref name="T"/>.
                /// </summary>
                public abstract static global::System.Collections.Generic.IReadOnlyCollection<T> {{InterfaceProperty}} { get; }
            }
          }
          """;

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        context.RegisterPostInitializationOutput(ctx =>
        {
            ctx.AddSource(
                $"{AttributeName}.g.cs",
                SourceText.From(AttributeSourceText, Encoding.UTF8));
            ctx.AddSource(
                $"{InterfaceName}.g.cs",
                SourceText.From(InterfaceSourceText, Encoding.UTF8));
        });

        var provider = context.SyntaxProvider.CreateSyntaxProvider(
            (node, _) => node is TypeDeclarationSyntax, Transform)
            .Where(x => x.shouldGenerate)
            .Select((x, _) => x.type);

        context.RegisterSourceOutput(context.CompilationProvider.Combine(provider.Collect()),
            (ctx, t) => GenerateCode(ctx, t.Left, t.Right));
    }

    private static (TypeDeclarationSyntax type, bool shouldGenerate) Transform(GeneratorSyntaxContext ctx, CancellationToken ct)
    {
        var type = (TypeDeclarationSyntax)ctx.Node;

        // Go through all attributes of the class.
        foreach (var attributeList in type.AttributeLists)
        foreach (var attribute in attributeList.Attributes)
        {
            ct.ThrowIfCancellationRequested();

            if (ctx.SemanticModel.GetSymbolInfo(attribute).Symbol is not IMethodSymbol attributeSymbol)
                continue;

            var attributeName = attributeSymbol.ContainingType.ToDisplayString();

            // Check the full name of the [Report] attribute.
            if (attributeName == $"{Namespace}.{AttributeName}")
                return (type, true);
        }

        return (type, false);
    }

    private static void GenerateCode(
        SourceProductionContext context,
        Compilation compilation,
        ImmutableArray<TypeDeclarationSyntax> typeDeclarations)
    {
        // Go through all filtered class declarations.
        foreach (var type in typeDeclarations)
        {
            // We need to get semantic model of the class to retrieve metadata.
            var semanticModel = compilation.GetSemanticModel(type.SyntaxTree);

            // Symbols allow us to get the compile-time information.
            if (semanticModel.GetDeclaredSymbol(type) is not INamedTypeSymbol classSymbol)
                continue;

            var namespaceName = classSymbol.ContainingNamespace.ToDisplayString();

            // 'Identifier' means the token of the node. Get class name from the syntax node.
            var typeName = type.Identifier.Text;
            var keyword = type switch
            {
                ClassDeclarationSyntax cds => cds.Keyword.Text,
                StructDeclarationSyntax sds => sds.Keyword.Text,
                RecordDeclarationSyntax rds => $"{rds.Keyword.Text} {rds.ClassOrStructKeyword.Text}".TrimEnd(),
                _ => "class"
            };

            // Go through all class members with a particular type (property) to generate method lines.
            var properties = classSymbol.GetMembers()
                .OfType<IPropertySymbol>()
                .Where(x => x is
                {
                    IsStatic: true,
                    IsReadOnly: true
                });

            // Build up the source code
            var code =
                $$"""
                  // <auto-generated/>

                  using global::System.Collections.Generic;
                  using global::{{Namespace}};

                  namespace {{namespaceName}};

                  [global::System.CodeDom.Compiler.GeneratedCode("{{ToolName}}", "1.0")]
                  partial {{keyword}} {{typeName}} : global::{{Namespace}}.{{InterfaceName}}<{{typeName}}>
                  {
                      public static global::System.Collections.Generic.IReadOnlyCollection<{{typeName}}> {{InterfaceProperty}} { get; } = [
                  {{string.Join(",\n", properties.Select(x => $"\t\t{x.Name}"))}}
                      ];
                  }

                  """;

            // Add the source code to the compilation.
            context.AddSource($"{typeName}.g.cs", SourceText.From(code, Encoding.UTF8));
        }
    }
}